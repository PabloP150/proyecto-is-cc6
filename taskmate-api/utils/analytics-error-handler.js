const { analyticsLogger } = require('./analytics-logger');

/**
 * Comprehensive Error Handling System for Analytics
 * Implements requirement 7.2: Test LLM fallback scenarios and error handling
 */

class AnalyticsErrorHandler {
    
    constructor() {
        this.errorCounts = new Map();
        this.circuitBreakers = new Map();
        this.retryAttempts = new Map();
    }
    
    /**
     * Handle analytics service errors with fallback mechanisms
     */
    async handleServiceError(operation, error, fallbackFn = null, context = {}) {
        const errorKey = `${operation}_${error.code || 'UNKNOWN'}`;
        
        // Track error frequency
        this.trackError(errorKey);
        
        // Log the error
        analyticsLogger.logOperation(operation, context, null, error);
        
        // Determine error type and response strategy
        const errorType = this.classifyError(error);
        const response = await this.getErrorResponse(errorType, operation, error, fallbackFn, context);
        
        return response;
    }
    
    /**
     * Handle database connection errors with retry logic
     */
    async handleDatabaseError(operation, error, retryFn, maxRetries = 3) {\n        const retryKey = `db_${operation}`;\n        const currentAttempts = this.retryAttempts.get(retryKey) || 0;\n        \n        if (currentAttempts < maxRetries) {\n            this.retryAttempts.set(retryKey, currentAttempts + 1);\n            \n            // Exponential backoff\n            const delay = Math.pow(2, currentAttempts) * 1000;\n            \n            analyticsLogger.logOperation('DATABASE_RETRY', {\n                operation,\n                attempt: currentAttempts + 1,\n                maxRetries,\n                delay\n            });\n            \n            await this.sleep(delay);\n            \n            try {\n                const result = await retryFn();\n                this.retryAttempts.delete(retryKey); // Reset on success\n                return result;\n            } catch (retryError) {\n                return this.handleDatabaseError(operation, retryError, retryFn, maxRetries);\n            }\n        } else {\n            // Max retries exceeded, use fallback\n            this.retryAttempts.delete(retryKey);\n            \n            analyticsLogger.logOperation('DATABASE_FALLBACK', {\n                operation,\n                error: error.message,\n                attemptsExhausted: maxRetries\n            }, null, error);\n            \n            return this.getDatabaseFallback(operation);\n        }\n    }\n    \n    /**\n     * Handle LLM service errors with deterministic fallback\n     */\n    async handleLLMError(operation, error, deterministicFn, context = {}) {\n        analyticsLogger.logOperation('LLM_ERROR', {\n            operation,\n            error: error.message,\n            context\n        }, null, error);\n        \n        // Check circuit breaker for LLM service\n        if (this.isCircuitBreakerOpen('llm_service')) {\n            analyticsLogger.logOperation('LLM_CIRCUIT_BREAKER_OPEN', {\n                operation,\n                fallbackUsed: true\n            });\n            \n            return await deterministicFn();\n        }\n        \n        // Trip circuit breaker if too many failures\n        this.updateCircuitBreaker('llm_service', false);\n        \n        // Use deterministic fallback\n        try {\n            const fallbackResult = await deterministicFn();\n            \n            analyticsLogger.logOperation('LLM_FALLBACK_SUCCESS', {\n                operation,\n                fallbackUsed: true\n            });\n            \n            return {\n                ...fallbackResult,\n                fallback_used: true,\n                fallback_reason: 'LLM service unavailable'\n            };\n        } catch (fallbackError) {\n            analyticsLogger.logOperation('LLM_FALLBACK_FAILED', {\n                operation,\n                originalError: error.message,\n                fallbackError: fallbackError.message\n            }, null, fallbackError);\n            \n            throw new AnalyticsError(\n                'Both LLM service and fallback failed',\n                'SERVICE_UNAVAILABLE',\n                { originalError: error.message, fallbackError: fallbackError.message }\n            );\n        }\n    }\n    \n    /**\n     * Handle API validation errors\n     */\n    handleValidationError(field, value, expectedType, context = {}) {\n        const error = new AnalyticsError(\n            `Validation failed for field '${field}': expected ${expectedType}, got ${typeof value}`,\n            'VALIDATION_ERROR',\n            { field, value, expectedType, context }\n        );\n        \n        analyticsLogger.logOperation('VALIDATION_ERROR', {\n            field,\n            value: typeof value,\n            expectedType,\n            context\n        }, null, error);\n        \n        return {\n            success: false,\n            error: error.message,\n            code: error.code,\n            field,\n            expectedType\n        };\n    }\n    \n    /**\n     * Handle permission/access errors\n     */\n    handleAccessError(userId, resource, action, context = {}) {\n        const error = new AnalyticsError(\n            `Access denied: User ${userId} cannot ${action} ${resource}`,\n            'ACCESS_DENIED',\n            { userId, resource, action, context }\n        );\n        \n        // Log security event\n        analyticsLogger.logSecurity('UNAUTHORIZED_ACCESS', {\n            userId,\n            resource,\n            action,\n            ip: context.ip,\n            userAgent: context.userAgent\n        });\n        \n        return {\n            success: false,\n            error: 'Access denied',\n            code: 'ACCESS_DENIED'\n        };\n    }\n    \n    /**\n     * Handle rate limiting errors\n     */\n    handleRateLimitError(userId, operation, limit, timeWindow) {\n        const error = new AnalyticsError(\n            `Rate limit exceeded: ${operation} for user ${userId}`,\n            'RATE_LIMIT_EXCEEDED',\n            { userId, operation, limit, timeWindow }\n        );\n        \n        analyticsLogger.logOperation('RATE_LIMIT_EXCEEDED', {\n            userId,\n            operation,\n            limit,\n            timeWindow\n        }, null, error);\n        \n        return {\n            success: false,\n            error: `Rate limit exceeded. Try again in ${timeWindow} seconds.`,\n            code: 'RATE_LIMIT_EXCEEDED',\n            retryAfter: timeWindow\n        };\n    }\n    \n    /**\n     * Create standardized error response\n     */\n    createErrorResponse(message, code, statusCode = 500, details = {}) {\n        return {\n            success: false,\n            error: message,\n            code,\n            statusCode,\n            details,\n            timestamp: new Date().toISOString()\n        };\n    }\n    \n    /**\n     * Wrap async functions with error handling\n     */\n    wrapAsync(fn, operation, fallbackFn = null) {\n        return async (...args) => {\n            try {\n                return await fn(...args);\n            } catch (error) {\n                return await this.handleServiceError(operation, error, fallbackFn, { args });\n            }\n        };\n    }\n    \n    // Private helper methods\n    \n    /**\n     * Classify error types for appropriate handling\n     */\n    classifyError(error) {\n        if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {\n            return 'CONNECTION_ERROR';\n        }\n        \n        if (error.message.includes('Invalid GUID') || error.message.includes('Validation failed')) {\n            return 'VALIDATION_ERROR';\n        }\n        \n        if (error.message.includes('Invalid object name') || error.code === 'EREQUEST') {\n            return 'DATABASE_ERROR';\n        }\n        \n        if (error.message.includes('LLM') || error.message.includes('AI service')) {\n            return 'LLM_ERROR';\n        }\n        \n        if (error.code === 'EPERM' || error.message.includes('Access denied')) {\n            return 'ACCESS_ERROR';\n        }\n        \n        return 'UNKNOWN_ERROR';\n    }\n    \n    /**\n     * Get appropriate error response based on error type\n     */\n    async getErrorResponse(errorType, operation, error, fallbackFn, context) {\n        switch (errorType) {\n            case 'CONNECTION_ERROR':\n                return this.createErrorResponse(\n                    'Service temporarily unavailable',\n                    'SERVICE_UNAVAILABLE',\n                    503\n                );\n                \n            case 'VALIDATION_ERROR':\n                return this.createErrorResponse(\n                    'Invalid input data',\n                    'VALIDATION_ERROR',\n                    400,\n                    { originalError: error.message }\n                );\n                \n            case 'DATABASE_ERROR':\n                if (fallbackFn) {\n                    try {\n                        const fallbackResult = await fallbackFn();\n                        return {\n                            ...fallbackResult,\n                            fallback_used: true,\n                            fallback_reason: 'Database unavailable'\n                        };\n                    } catch (fallbackError) {\n                        return this.createErrorResponse(\n                            'Data service unavailable',\n                            'DATABASE_UNAVAILABLE',\n                            503\n                        );\n                    }\n                }\n                return this.createErrorResponse(\n                    'Data service unavailable',\n                    'DATABASE_UNAVAILABLE',\n                    503\n                );\n                \n            case 'LLM_ERROR':\n                return this.createErrorResponse(\n                    'AI service temporarily unavailable',\n                    'AI_SERVICE_UNAVAILABLE',\n                    503\n                );\n                \n            case 'ACCESS_ERROR':\n                return this.createErrorResponse(\n                    'Access denied',\n                    'ACCESS_DENIED',\n                    403\n                );\n                \n            default:\n                return this.createErrorResponse(\n                    'Internal server error',\n                    'INTERNAL_ERROR',\n                    500\n                );\n        }\n    }\n    \n    /**\n     * Get database fallback data\n     */\n    getDatabaseFallback(operation) {\n        const fallbackData = {\n            getUserAnalytics: {\n                current_workload: 0,\n                expertise_by_category: {},\n                historical_capacity: 3,\n                updated_at: new Date().toISOString(),\n                fallback_used: true,\n                fallback_reason: 'Database unavailable'\n            },\n            getTeamAnalytics: {\n                team_members: [],\n                total_active_tasks: 0,\n                average_utilization: 0,\n                updated_at: new Date().toISOString(),\n                fallback_used: true,\n                fallback_reason: 'Database unavailable'\n            },\n            recordTaskAssignment: {\n                success: true,\n                message: 'Task assignment recorded (fallback mode)',\n                fallback_used: true,\n                fallback_reason: 'Database unavailable'\n            }\n        };\n        \n        return fallbackData[operation] || {\n            success: false,\n            error: 'Operation not available in fallback mode',\n            fallback_used: true\n        };\n    }\n    \n    /**\n     * Track error frequency for monitoring\n     */\n    trackError(errorKey) {\n        const count = this.errorCounts.get(errorKey) || 0;\n        this.errorCounts.set(errorKey, count + 1);\n        \n        // Alert on high error frequency\n        if (count > 10) {\n            analyticsLogger.logOperation('HIGH_ERROR_FREQUENCY', {\n                errorKey,\n                count: count + 1\n            });\n        }\n    }\n    \n    /**\n     * Circuit breaker implementation\n     */\n    updateCircuitBreaker(service, success) {\n        if (!this.circuitBreakers.has(service)) {\n            this.circuitBreakers.set(service, {\n                failures: 0,\n                lastFailure: null,\n                state: 'CLOSED' // CLOSED, OPEN, HALF_OPEN\n            });\n        }\n        \n        const breaker = this.circuitBreakers.get(service);\n        \n        if (success) {\n            breaker.failures = 0;\n            breaker.state = 'CLOSED';\n        } else {\n            breaker.failures++;\n            breaker.lastFailure = Date.now();\n            \n            if (breaker.failures >= 5) {\n                breaker.state = 'OPEN';\n            }\n        }\n    }\n    \n    /**\n     * Check if circuit breaker is open\n     */\n    isCircuitBreakerOpen(service) {\n        const breaker = this.circuitBreakers.get(service);\n        if (!breaker) return false;\n        \n        if (breaker.state === 'OPEN') {\n            // Check if enough time has passed to try again\n            const timeSinceFailure = Date.now() - breaker.lastFailure;\n            if (timeSinceFailure > 60000) { // 1 minute\n                breaker.state = 'HALF_OPEN';\n                return false;\n            }\n            return true;\n        }\n        \n        return false;\n    }\n    \n    /**\n     * Sleep utility for retry delays\n     */\n    sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    \n    /**\n     * Get error statistics\n     */\n    getErrorStats() {\n        const stats = {\n            errorCounts: Object.fromEntries(this.errorCounts),\n            circuitBreakers: {},\n            totalErrors: 0\n        };\n        \n        // Convert circuit breaker map to object\n        for (const [service, breaker] of this.circuitBreakers) {\n            stats.circuitBreakers[service] = {\n                ...breaker,\n                isOpen: this.isCircuitBreakerOpen(service)\n            };\n        }\n        \n        // Calculate total errors\n        for (const count of this.errorCounts.values()) {\n            stats.totalErrors += count;\n        }\n        \n        return stats;\n    }\n}\n\n/**\n * Custom Analytics Error class\n */\nclass AnalyticsError extends Error {\n    constructor(message, code, details = {}) {\n        super(message);\n        this.name = 'AnalyticsError';\n        this.code = code;\n        this.details = details;\n        this.timestamp = new Date().toISOString();\n    }\n}\n\n// Create singleton instance\nconst analyticsErrorHandler = new AnalyticsErrorHandler();\n\n// Express error handling middleware\nconst errorHandlerMiddleware = (error, req, res, next) => {\n    const operation = `${req.method} ${req.originalUrl}`;\n    \n    analyticsLogger.logOperation('API_ERROR', {\n        operation,\n        error: error.message,\n        stack: error.stack,\n        userId: req.analytics?.requesterId\n    }, null, error);\n    \n    // Determine response based on error type\n    let response;\n    \n    if (error instanceof AnalyticsError) {\n        response = {\n            success: false,\n            error: error.message,\n            code: error.code,\n            details: error.details\n        };\n        res.status(error.details.statusCode || 500);\n    } else {\n        const errorType = analyticsErrorHandler.classifyError(error);\n        response = analyticsErrorHandler.createErrorResponse(\n            'An error occurred processing your request',\n            errorType,\n            500\n        );\n        res.status(response.statusCode);\n    }\n    \n    res.json(response);\n};\n\nmodule.exports = {\n    AnalyticsErrorHandler,\n    AnalyticsError,\n    analyticsErrorHandler,\n    errorHandlerMiddleware\n};"