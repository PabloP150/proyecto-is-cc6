const { execReadCommand } = require('../helpers/execQuery');
const { analyticsLogger } = require('./analytics-logger');
const { analyticsCleanup } = require('./analytics-cleanup');

/**
 * Analytics System Health Monitoring
 * Implements requirement 7.4: Add monitoring for analytics system health and performance
 */
class AnalyticsHealthMonitor {
    
    constructor() {
        this.healthChecks = {
            database: {
                name: 'Database Connectivity',
                critical: true,
                timeout: 5000
            },
            tables: {
                name: 'Analytics Tables',
                critical: true,
                timeout: 3000
            },
            dataIntegrity: {
                name: 'Data Integrity',
                critical: false,
                timeout: 10000
            },
            performance: {
                name: 'System Performance',
                critical: false,
                timeout: 5000
            },
            storage: {
                name: 'Storage Usage',
                critical: false,
                timeout: 3000
            }
        };
        
        this.healthHistory = [];
        this.alertThresholds = {
            responseTime: 2000, // 2 seconds
            errorRate: 5, // 5%
            memoryUsage: 500 * 1024 * 1024, // 500MB
            diskUsage: 80, // 80%
            connectionCount: 100
        };
    }
    
    /**
     * Perform comprehensive health check
     */
    async performHealthCheck() {
        const startTime = Date.now();
        const healthReport = {
            timestamp: new Date().toISOString(),
            overall_status: 'healthy',
            checks: {},
            metrics: {},
            alerts: [],
            duration: 0
        };
        
        let criticalFailures = 0;\n        let warnings = 0;\n        \n        // Run all health checks\n        for (const [checkName, checkConfig] of Object.entries(this.healthChecks)) {\n            try {\n                const checkResult = await this.runHealthCheck(checkName, checkConfig);\n                healthReport.checks[checkName] = checkResult;\n                \n                if (!checkResult.healthy) {\n                    if (checkConfig.critical) {\n                        criticalFailures++;\n                    } else {\n                        warnings++;\n                    }\n                }\n                \n            } catch (error) {\n                healthReport.checks[checkName] = {\n                    healthy: false,\n                    error: error.message,\n                    critical: checkConfig.critical\n                };\n                \n                if (checkConfig.critical) {\n                    criticalFailures++;\n                }\n            }\n        }\n        \n        // Collect system metrics\n        healthReport.metrics = await this.collectSystemMetrics();\n        \n        // Generate alerts\n        healthReport.alerts = this.generateAlerts(healthReport.checks, healthReport.metrics);\n        \n        // Determine overall status\n        if (criticalFailures > 0) {\n            healthReport.overall_status = 'unhealthy';\n        } else if (warnings > 0 || healthReport.alerts.length > 0) {\n            healthReport.overall_status = 'degraded';\n        }\n        \n        healthReport.duration = Date.now() - startTime;\n        \n        // Store health history\n        this.storeHealthHistory(healthReport);\n        \n        // Log health check\n        analyticsLogger.logOperation('HEALTH_CHECK', {\n            status: healthReport.overall_status,\n            criticalFailures,\n            warnings,\n            alerts: healthReport.alerts.length,\n            duration: healthReport.duration\n        });\n        \n        return healthReport;\n    }\n    \n    /**\n     * Run individual health check\n     */\n    async runHealthCheck(checkName, config) {\n        const startTime = Date.now();\n        \n        try {\n            let result;\n            \n            switch (checkName) {\n                case 'database':\n                    result = await this.checkDatabaseConnectivity();\n                    break;\n                case 'tables':\n                    result = await this.checkAnalyticsTables();\n                    break;\n                case 'dataIntegrity':\n                    result = await this.checkDataIntegrity();\n                    break;\n                case 'performance':\n                    result = await this.checkPerformance();\n                    break;\n                case 'storage':\n                    result = await this.checkStorageUsage();\n                    break;\n                default:\n                    throw new Error(`Unknown health check: ${checkName}`);\n            }\n            \n            const duration = Date.now() - startTime;\n            \n            return {\n                healthy: result.healthy,\n                message: result.message,\n                details: result.details,\n                duration,\n                critical: config.critical\n            };\n            \n        } catch (error) {\n            const duration = Date.now() - startTime;\n            \n            return {\n                healthy: false,\n                message: `Health check failed: ${error.message}`,\n                error: error.message,\n                duration,\n                critical: config.critical\n            };\n        }\n    }\n    \n    /**\n     * Check database connectivity\n     */\n    async checkDatabaseConnectivity() {\n        try {\n            const query = 'SELECT 1 as test';\n            const result = await execReadCommand(query);\n            \n            return {\n                healthy: result && result.length > 0,\n                message: 'Database connection successful',\n                details: {\n                    connected: true,\n                    responseTime: 'fast'\n                }\n            };\n            \n        } catch (error) {\n            return {\n                healthy: false,\n                message: 'Database connection failed',\n                details: {\n                    connected: false,\n                    error: error.message\n                }\n            };\n        }\n    }\n    \n    /**\n     * Check analytics tables existence and structure\n     */\n    async checkAnalyticsTables() {\n        const requiredTables = ['TaskAnalytics', 'UserMetrics', 'UserExpertise'];\n        const tableStatus = {};\n        let healthyTables = 0;\n        \n        for (const table of requiredTables) {\n            try {\n                const query = `\n                    SELECT COUNT(*) as count \n                    FROM INFORMATION_SCHEMA.TABLES \n                    WHERE TABLE_NAME = '${table}' AND TABLE_SCHEMA = 'dbo'\n                `;\n                \n                const result = await execReadCommand(query);\n                const exists = result[0]?.count > 0;\n                \n                tableStatus[table] = {\n                    exists,\n                    status: exists ? 'healthy' : 'missing'\n                };\n                \n                if (exists) {\n                    healthyTables++;\n                }\n                \n            } catch (error) {\n                tableStatus[table] = {\n                    exists: false,\n                    status: 'error',\n                    error: error.message\n                };\n            }\n        }\n        \n        const allTablesHealthy = healthyTables === requiredTables.length;\n        \n        return {\n            healthy: allTablesHealthy,\n            message: allTablesHealthy \n                ? 'All analytics tables are present' \n                : `${healthyTables}/${requiredTables.length} analytics tables are present`,\n            details: {\n                requiredTables: requiredTables.length,\n                healthyTables,\n                tables: tableStatus\n            }\n        };\n    }\n    \n    /**\n     * Check data integrity\n     */\n    async checkDataIntegrity() {\n        const integrityChecks = {\n            orphanedRecords: 0,\n            duplicateRecords: 0,\n            invalidData: 0\n        };\n        \n        try {\n            // Check for orphaned TaskAnalytics records\n            const orphanedQuery = `\n                SELECT COUNT(*) as count\n                FROM dbo.TaskAnalytics ta\n                LEFT JOIN dbo.Tasks t ON ta.tid = t.tid\n                WHERE t.tid IS NULL\n            `;\n            \n            const orphanedResult = await execReadCommand(orphanedQuery);\n            integrityChecks.orphanedRecords = orphanedResult[0]?.count || 0;\n            \n            // Check for duplicate UserMetrics records\n            const duplicateQuery = `\n                SELECT COUNT(*) as count\n                FROM (\n                    SELECT uid, metric_date, COUNT(*) as cnt\n                    FROM dbo.UserMetrics\n                    GROUP BY uid, metric_date\n                    HAVING COUNT(*) > 1\n                ) duplicates\n            `;\n            \n            const duplicateResult = await execReadCommand(duplicateQuery);\n            integrityChecks.duplicateRecords = duplicateResult[0]?.count || 0;\n            \n            const totalIssues = integrityChecks.orphanedRecords + integrityChecks.duplicateRecords + integrityChecks.invalidData;\n            \n            return {\n                healthy: totalIssues === 0,\n                message: totalIssues === 0 \n                    ? 'Data integrity checks passed' \n                    : `Found ${totalIssues} data integrity issues`,\n                details: integrityChecks\n            };\n            \n        } catch (error) {\n            // If tables don't exist, consider it healthy (development scenario)\n            if (error.message.includes('Invalid object name')) {\n                return {\n                    healthy: true,\n                    message: 'Analytics tables not yet created (development mode)',\n                    details: { tablesExist: false }\n                };\n            }\n            \n            throw error;\n        }\n    }\n    \n    /**\n     * Check system performance\n     */\n    async checkPerformance() {\n        const performanceMetrics = {\n            memoryUsage: process.memoryUsage(),\n            cpuUsage: process.cpuUsage(),\n            uptime: process.uptime()\n        };\n        \n        // Get analytics service metrics\n        const analyticsMetrics = analyticsLogger.getMetrics();\n        \n        const issues = [];\n        \n        // Check memory usage\n        if (performanceMetrics.memoryUsage.heapUsed > this.alertThresholds.memoryUsage) {\n            issues.push('High memory usage detected');\n        }\n        \n        // Check average response time\n        if (analyticsMetrics.avgResponseTime > this.alertThresholds.responseTime) {\n            issues.push('High average response time');\n        }\n        \n        // Check error rate\n        if (analyticsMetrics.errorRate > this.alertThresholds.errorRate) {\n            issues.push('High error rate detected');\n        }\n        \n        return {\n            healthy: issues.length === 0,\n            message: issues.length === 0 \n                ? 'Performance metrics are within normal ranges' \n                : `Performance issues detected: ${issues.join(', ')}`,\n            details: {\n                memory: {\n                    heapUsed: Math.round(performanceMetrics.memoryUsage.heapUsed / 1024 / 1024),\n                    heapTotal: Math.round(performanceMetrics.memoryUsage.heapTotal / 1024 / 1024),\n                    threshold: Math.round(this.alertThresholds.memoryUsage / 1024 / 1024)\n                },\n                performance: {\n                    avgResponseTime: Math.round(analyticsMetrics.avgResponseTime),\n                    errorRate: Math.round(analyticsMetrics.errorRate * 100) / 100,\n                    requestsPerHour: Math.round(analyticsMetrics.requestsPerHour)\n                },\n                issues\n            }\n        };\n    }\n    \n    /**\n     * Check storage usage\n     */\n    async checkStorageUsage() {\n        try {\n            // Get database size information\n            const sizeQuery = `\n                SELECT \n                    SUM(size * 8.0 / 1024) as size_mb\n                FROM sys.master_files\n                WHERE database_id = DB_ID()\n            `;\n            \n            const sizeResult = await execReadCommand(sizeQuery);\n            const databaseSizeMB = sizeResult[0]?.size_mb || 0;\n            \n            // Get analytics table sizes\n            const tableSizeQuery = `\n                SELECT \n                    t.NAME AS TableName,\n                    s.Name AS SchemaName,\n                    p.rows AS RowCounts,\n                    SUM(a.total_pages) * 8 AS TotalSpaceKB\n                FROM sys.tables t\n                INNER JOIN sys.indexes i ON t.OBJECT_ID = i.object_id\n                INNER JOIN sys.partitions p ON i.object_id = p.OBJECT_ID AND i.index_id = p.index_id\n                INNER JOIN sys.allocation_units a ON p.partition_id = a.container_id\n                LEFT OUTER JOIN sys.schemas s ON t.schema_id = s.schema_id\n                WHERE t.NAME IN ('TaskAnalytics', 'UserMetrics', 'UserExpertise')\n                GROUP BY t.Name, s.Name, p.Rows\n            `;\n            \n            const tableSizeResult = await execReadCommand(tableSizeQuery);\n            \n            const tableInfo = {};\n            let totalAnalyticsSpaceKB = 0;\n            \n            for (const row of tableSizeResult) {\n                tableInfo[row.TableName] = {\n                    rows: row.RowCounts,\n                    sizeKB: row.TotalSpaceKB\n                };\n                totalAnalyticsSpaceKB += row.TotalSpaceKB;\n            }\n            \n            return {\n                healthy: true, // Storage checks are informational for now\n                message: `Database size: ${Math.round(databaseSizeMB)}MB, Analytics tables: ${Math.round(totalAnalyticsSpaceKB / 1024)}MB`,\n                details: {\n                    databaseSizeMB: Math.round(databaseSizeMB),\n                    analyticsSpaceMB: Math.round(totalAnalyticsSpaceKB / 1024),\n                    tables: tableInfo\n                }\n            };\n            \n        } catch (error) {\n            // If we can't get storage info, it's not critical\n            return {\n                healthy: true,\n                message: 'Storage information unavailable',\n                details: { error: error.message }\n            };\n        }\n    }\n    \n    /**\n     * Collect system metrics\n     */\n    async collectSystemMetrics() {\n        const metrics = {\n            timestamp: new Date().toISOString(),\n            system: {\n                uptime: process.uptime(),\n                memory: process.memoryUsage(),\n                cpu: process.cpuUsage()\n            },\n            analytics: analyticsLogger.getMetrics(),\n            cleanup: analyticsCleanup.getCleanupStats()\n        };\n        \n        return metrics;\n    }\n    \n    /**\n     * Generate alerts based on health checks and metrics\n     */\n    generateAlerts(checks, metrics) {\n        const alerts = [];\n        \n        // Critical system alerts\n        if (!checks.database?.healthy) {\n            alerts.push({\n                level: 'critical',\n                message: 'Database connectivity failed',\n                component: 'database',\n                timestamp: new Date().toISOString()\n            });\n        }\n        \n        if (!checks.tables?.healthy) {\n            alerts.push({\n                level: 'warning',\n                message: 'Some analytics tables are missing',\n                component: 'tables',\n                timestamp: new Date().toISOString()\n            });\n        }\n        \n        // Performance alerts\n        if (metrics.analytics.errorRate > this.alertThresholds.errorRate) {\n            alerts.push({\n                level: 'warning',\n                message: `High error rate: ${metrics.analytics.errorRate.toFixed(2)}%`,\n                component: 'performance',\n                timestamp: new Date().toISOString()\n            });\n        }\n        \n        if (metrics.analytics.avgResponseTime > this.alertThresholds.responseTime) {\n            alerts.push({\n                level: 'warning',\n                message: `Slow response time: ${Math.round(metrics.analytics.avgResponseTime)}ms`,\n                component: 'performance',\n                timestamp: new Date().toISOString()\n            });\n        }\n        \n        // Memory alerts\n        if (metrics.system.memory.heapUsed > this.alertThresholds.memoryUsage) {\n            alerts.push({\n                level: 'warning',\n                message: `High memory usage: ${Math.round(metrics.system.memory.heapUsed / 1024 / 1024)}MB`,\n                component: 'memory',\n                timestamp: new Date().toISOString()\n            });\n        }\n        \n        return alerts;\n    }\n    \n    /**\n     * Store health history for trend analysis\n     */\n    storeHealthHistory(healthReport) {\n        this.healthHistory.push({\n            timestamp: healthReport.timestamp,\n            status: healthReport.overall_status,\n            duration: healthReport.duration,\n            alerts: healthReport.alerts.length,\n            criticalFailures: Object.values(healthReport.checks)\n                .filter(check => !check.healthy && check.critical).length\n        });\n        \n        // Keep only last 100 health reports\n        if (this.healthHistory.length > 100) {\n            this.healthHistory = this.healthHistory.slice(-100);\n        }\n    }\n    \n    /**\n     * Get health trends\n     */\n    getHealthTrends() {\n        if (this.healthHistory.length === 0) {\n            return {\n                trend: 'stable',\n                message: 'No health history available',\n                data: []\n            };\n        }\n        \n        const recent = this.healthHistory.slice(-10);\n        const healthyCount = recent.filter(h => h.status === 'healthy').length;\n        const degradedCount = recent.filter(h => h.status === 'degraded').length;\n        const unhealthyCount = recent.filter(h => h.status === 'unhealthy').length;\n        \n        let trend = 'stable';\n        let message = 'System health is stable';\n        \n        if (unhealthyCount > 3) {\n            trend = 'declining';\n            message = 'System health is declining - multiple critical issues detected';\n        } else if (degradedCount > 5) {\n            trend = 'degrading';\n            message = 'System health is degrading - performance issues detected';\n        } else if (healthyCount === recent.length) {\n            trend = 'improving';\n            message = 'System health is excellent';\n        }\n        \n        return {\n            trend,\n            message,\n            data: {\n                totalChecks: this.healthHistory.length,\n                recentChecks: recent.length,\n                healthyCount,\n                degradedCount,\n                unhealthyCount,\n                avgDuration: Math.round(recent.reduce((sum, h) => sum + h.duration, 0) / recent.length)\n            }\n        };\n    }\n    \n    /**\n     * Get health summary\n     */\n    getHealthSummary() {\n        const trends = this.getHealthTrends();\n        const lastCheck = this.healthHistory[this.healthHistory.length - 1];\n        \n        return {\n            lastCheck: lastCheck ? {\n                timestamp: lastCheck.timestamp,\n                status: lastCheck.status,\n                duration: lastCheck.duration\n            } : null,\n            trends,\n            alertThresholds: this.alertThresholds,\n            healthChecks: Object.keys(this.healthChecks)\n        };\n    }\n}\n\n// Create singleton instance\nconst analyticsHealthMonitor = new AnalyticsHealthMonitor();\n\nmodule.exports = {\n    AnalyticsHealthMonitor,\n    analyticsHealthMonitor\n};"