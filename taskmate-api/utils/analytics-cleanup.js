const { execReadCommand, execWriteCommand } = require('../helpers/execQuery');
const { TYPES } = require('tedious');
const { analyticsLogger } = require('./analytics-logger');
const cron = require('node-cron');

/**
 * Analytics Data Cleanup and Retention System
 * Implements requirements 6.1, 6.2: Data retention policies and cleanup mechanisms
 */
class AnalyticsCleanup {
    
    constructor() {
        this.retentionPolicies = {
            taskAnalytics: {
                retentionDays: 365,
                archiveAfterDays: 90,
                cleanupBatchSize: 1000
            },
            userMetrics: {
                retentionDays: 730, // 2 years
                archiveAfterDays: 180,
                cleanupBatchSize: 500
            },
            userExpertise: {
                retentionDays: 1095, // 3 years
                archiveAfterDays: 365,
                cleanupBatchSize: 500
            },
            logs: {
                retentionDays: 30,
                archiveAfterDays: 7,
                cleanupBatchSize: 5000
            }
        };
        
        this.cleanupStats = {
            lastRun: null,
            totalRecordsProcessed: 0,
            totalRecordsDeleted: 0,
            totalRecordsArchived: 0,
            errors: []
        };
    }
    
    /**
     * Initialize scheduled cleanup jobs
     */
    initializeCleanupJobs() {\n        console.log('Initializing analytics cleanup jobs...');\n        \n        // Daily cleanup at 2 AM\n        this.scheduleDailyCleanup();\n        \n        // Weekly deep cleanup on Sundays at 3 AM\n        this.scheduleWeeklyDeepCleanup();\n        \n        // Monthly archive job on 1st of month at 4 AM\n        this.scheduleMonthlyArchive();\n        \n        console.log('Analytics cleanup jobs initialized successfully');\n    }\n    \n    /**\n     * Schedule daily cleanup job\n     */\n    scheduleDailyCleanup() {\n        cron.schedule('0 2 * * *', async () => {\n            console.log('Starting daily analytics cleanup...');\n            \n            try {\n                const result = await this.performDailyCleanup();\n                \n                analyticsLogger.logOperation('DAILY_CLEANUP_COMPLETED', {\n                    recordsProcessed: result.recordsProcessed,\n                    recordsDeleted: result.recordsDeleted,\n                    duration: result.duration,\n                    errors: result.errors.length\n                });\n                \n                console.log('Daily cleanup completed:', result);\n                \n            } catch (error) {\n                analyticsLogger.logOperation('DAILY_CLEANUP_FAILED', {\n                    error: error.message\n                }, null, error);\n                \n                console.error('Daily cleanup failed:', error);\n            }\n        }, {\n            scheduled: true,\n            timezone: \"UTC\"\n        });\n        \n        console.log('Scheduled daily cleanup job (2 AM UTC)');\n    }\n    \n    /**\n     * Schedule weekly deep cleanup job\n     */\n    scheduleWeeklyDeepCleanup() {\n        cron.schedule('0 3 * * 0', async () => {\n            console.log('Starting weekly deep cleanup...');\n            \n            try {\n                const result = await this.performDeepCleanup();\n                \n                analyticsLogger.logOperation('WEEKLY_DEEP_CLEANUP_COMPLETED', {\n                    tablesProcessed: result.tablesProcessed,\n                    recordsDeleted: result.recordsDeleted,\n                    indexesOptimized: result.indexesOptimized,\n                    duration: result.duration\n                });\n                \n                console.log('Weekly deep cleanup completed:', result);\n                \n            } catch (error) {\n                analyticsLogger.logOperation('WEEKLY_DEEP_CLEANUP_FAILED', {\n                    error: error.message\n                }, null, error);\n                \n                console.error('Weekly deep cleanup failed:', error);\n            }\n        }, {\n            scheduled: true,\n            timezone: \"UTC\"\n        });\n        \n        console.log('Scheduled weekly deep cleanup job (Sundays 3 AM UTC)');\n    }\n    \n    /**\n     * Schedule monthly archive job\n     */\n    scheduleMonthlyArchive() {\n        cron.schedule('0 4 1 * *', async () => {\n            console.log('Starting monthly archive job...');\n            \n            try {\n                const result = await this.performMonthlyArchive();\n                \n                analyticsLogger.logOperation('MONTHLY_ARCHIVE_COMPLETED', {\n                    recordsArchived: result.recordsArchived,\n                    archiveSize: result.archiveSize,\n                    duration: result.duration\n                });\n                \n                console.log('Monthly archive completed:', result);\n                \n            } catch (error) {\n                analyticsLogger.logOperation('MONTHLY_ARCHIVE_FAILED', {\n                    error: error.message\n                }, null, error);\n                \n                console.error('Monthly archive failed:', error);\n            }\n        }, {\n            scheduled: true,\n            timezone: \"UTC\"\n        });\n        \n        console.log('Scheduled monthly archive job (1st of month 4 AM UTC)');\n    }\n    \n    /**\n     * Perform daily cleanup operations\n     */\n    async performDailyCleanup() {\n        const startTime = Date.now();\n        let recordsProcessed = 0;\n        let recordsDeleted = 0;\n        const errors = [];\n        \n        try {\n            // Clean up old task analytics records\n            const taskAnalyticsResult = await this.cleanupOldRecords(\n                'TaskAnalytics',\n                this.retentionPolicies.taskAnalytics.retentionDays\n            );\n            recordsDeleted += taskAnalyticsResult.deleted;\n            recordsProcessed += taskAnalyticsResult.processed;\n            \n            // Clean up orphaned records\n            const orphanedResult = await this.cleanupOrphanedRecords();\n            recordsDeleted += orphanedResult.deleted;\n            recordsProcessed += orphanedResult.processed;\n            \n            // Update cleanup statistics\n            this.updateCleanupStats(recordsProcessed, recordsDeleted, 0, errors);\n            \n        } catch (error) {\n            errors.push(error.message);\n        }\n        \n        const duration = Date.now() - startTime;\n        \n        return {\n            recordsProcessed,\n            recordsDeleted,\n            duration,\n            errors\n        };\n    }\n    \n    /**\n     * Perform deep cleanup operations\n     */\n    async performDeepCleanup() {\n        const startTime = Date.now();\n        let tablesProcessed = 0;\n        let recordsDeleted = 0;\n        let indexesOptimized = 0;\n        \n        try {\n            // Clean up all analytics tables\n            const tables = ['TaskAnalytics', 'UserMetrics', 'UserExpertise'];\n            \n            for (const table of tables) {\n                const policy = this.retentionPolicies[table.toLowerCase()] || this.retentionPolicies.taskAnalytics;\n                \n                const result = await this.cleanupOldRecords(table, policy.retentionDays);\n                recordsDeleted += result.deleted;\n                tablesProcessed++;\n            }\n            \n            // Optimize database indexes\n            indexesOptimized = await this.optimizeIndexes();\n            \n            // Rebuild statistics\n            await this.rebuildStatistics();\n            \n        } catch (error) {\n            console.error('Deep cleanup error:', error);\n        }\n        \n        const duration = Date.now() - startTime;\n        \n        return {\n            tablesProcessed,\n            recordsDeleted,\n            indexesOptimized,\n            duration\n        };\n    }\n    \n    /**\n     * Perform monthly archive operations\n     */\n    async performMonthlyArchive() {\n        const startTime = Date.now();\n        let recordsArchived = 0;\n        let archiveSize = 0;\n        \n        try {\n            // Archive old task analytics data\n            const taskAnalyticsArchive = await this.archiveOldRecords(\n                'TaskAnalytics',\n                this.retentionPolicies.taskAnalytics.archiveAfterDays\n            );\n            recordsArchived += taskAnalyticsArchive.archived;\n            archiveSize += taskAnalyticsArchive.size;\n            \n            // Archive old user metrics data\n            const userMetricsArchive = await this.archiveOldRecords(\n                'UserMetrics',\n                this.retentionPolicies.userMetrics.archiveAfterDays\n            );\n            recordsArchived += userMetricsArchive.archived;\n            archiveSize += userMetricsArchive.size;\n            \n            // Update cleanup statistics\n            this.updateCleanupStats(0, 0, recordsArchived, []);\n            \n        } catch (error) {\n            console.error('Monthly archive error:', error);\n        }\n        \n        const duration = Date.now() - startTime;\n        \n        return {\n            recordsArchived,\n            archiveSize,\n            duration\n        };\n    }\n    \n    /**\n     * Clean up old records from a specific table\n     */\n    async cleanupOldRecords(tableName, retentionDays) {\n        try {\n            // First, count records to be deleted\n            const countQuery = `\n                SELECT COUNT(*) as count\n                FROM dbo.${tableName}\n                WHERE created_at < DATEADD(day, -@retentionDays, GETDATE())\n            `;\n            \n            const countParams = [\n                { name: 'retentionDays', type: TYPES.Int, value: retentionDays }\n            ];\n            \n            const countResult = await execReadCommand(countQuery, countParams);\n            const recordsToDelete = countResult[0]?.count || 0;\n            \n            if (recordsToDelete === 0) {\n                return { processed: 0, deleted: 0 };\n            }\n            \n            // Delete old records in batches\n            const batchSize = this.retentionPolicies[tableName.toLowerCase()]?.cleanupBatchSize || 1000;\n            let totalDeleted = 0;\n            \n            while (totalDeleted < recordsToDelete) {\n                const deleteQuery = `\n                    DELETE TOP(@batchSize) FROM dbo.${tableName}\n                    WHERE created_at < DATEADD(day, -@retentionDays, GETDATE())\n                `;\n                \n                const deleteParams = [\n                    { name: 'batchSize', type: TYPES.Int, value: batchSize },\n                    { name: 'retentionDays', type: TYPES.Int, value: retentionDays }\n                ];\n                \n                const deletedCount = await execWriteCommand(deleteQuery, deleteParams);\n                totalDeleted += deletedCount;\n                \n                // Small delay between batches to avoid overwhelming the database\n                await this.sleep(100);\n                \n                if (deletedCount === 0) break; // No more records to delete\n            }\n            \n            analyticsLogger.logOperation('CLEANUP_OLD_RECORDS', {\n                table: tableName,\n                retentionDays,\n                recordsDeleted: totalDeleted\n            });\n            \n            return { processed: recordsToDelete, deleted: totalDeleted };\n            \n        } catch (error) {\n            // If table doesn't exist, return success (expected during development)\n            if (error.message.includes('Invalid object name')) {\n                console.log(`Table ${tableName} does not exist, skipping cleanup`);\n                return { processed: 0, deleted: 0 };\n            }\n            throw error;\n        }\n    }\n    \n    /**\n     * Clean up orphaned records (records referencing non-existent entities)\n     */\n    async cleanupOrphanedRecords() {\n        let totalDeleted = 0;\n        let totalProcessed = 0;\n        \n        try {\n            // Clean up TaskAnalytics records with non-existent tasks\n            const orphanedTaskAnalyticsQuery = `\n                DELETE ta FROM dbo.TaskAnalytics ta\n                LEFT JOIN dbo.Tasks t ON ta.tid = t.tid\n                WHERE t.tid IS NULL\n            `;\n            \n            const deletedTaskAnalytics = await execWriteCommand(orphanedTaskAnalyticsQuery);\n            totalDeleted += deletedTaskAnalytics;\n            totalProcessed += deletedTaskAnalytics;\n            \n            // Clean up UserMetrics records with non-existent users\n            const orphanedUserMetricsQuery = `\n                DELETE um FROM dbo.UserMetrics um\n                LEFT JOIN dbo.Users u ON um.uid = u.uid\n                WHERE u.uid IS NULL\n            `;\n            \n            const deletedUserMetrics = await execWriteCommand(orphanedUserMetricsQuery);\n            totalDeleted += deletedUserMetrics;\n            totalProcessed += deletedUserMetrics;\n            \n            // Clean up UserExpertise records with non-existent users\n            const orphanedUserExpertiseQuery = `\n                DELETE ue FROM dbo.UserExpertise ue\n                LEFT JOIN dbo.Users u ON ue.uid = u.uid\n                WHERE u.uid IS NULL\n            `;\n            \n            const deletedUserExpertise = await execWriteCommand(orphanedUserExpertiseQuery);\n            totalDeleted += deletedUserExpertise;\n            totalProcessed += deletedUserExpertise;\n            \n            analyticsLogger.logOperation('CLEANUP_ORPHANED_RECORDS', {\n                taskAnalyticsDeleted: deletedTaskAnalytics,\n                userMetricsDeleted: deletedUserMetrics,\n                userExpertiseDeleted: deletedUserExpertise,\n                totalDeleted\n            });\n            \n        } catch (error) {\n            if (error.message.includes('Invalid object name')) {\n                console.log('Analytics tables do not exist, skipping orphaned record cleanup');\n                return { processed: 0, deleted: 0 };\n            }\n            throw error;\n        }\n        \n        return { processed: totalProcessed, deleted: totalDeleted };\n    }\n    \n    /**\n     * Archive old records to separate archive tables\n     */\n    async archiveOldRecords(tableName, archiveAfterDays) {\n        try {\n            const archiveTableName = `${tableName}_Archive`;\n            \n            // Create archive table if it doesn't exist\n            await this.createArchiveTable(tableName, archiveTableName);\n            \n            // Move old records to archive\n            const archiveQuery = `\n                INSERT INTO dbo.${archiveTableName}\n                SELECT * FROM dbo.${tableName}\n                WHERE created_at < DATEADD(day, -@archiveAfterDays, GETDATE())\n                  AND created_at >= DATEADD(day, -@retentionDays, GETDATE())\n            `;\n            \n            const retentionDays = this.retentionPolicies[tableName.toLowerCase()]?.retentionDays || 365;\n            \n            const archiveParams = [\n                { name: 'archiveAfterDays', type: TYPES.Int, value: archiveAfterDays },\n                { name: 'retentionDays', type: TYPES.Int, value: retentionDays }\n            ];\n            \n            const archivedCount = await execWriteCommand(archiveQuery, archiveParams);\n            \n            // Delete archived records from main table\n            const deleteQuery = `\n                DELETE FROM dbo.${tableName}\n                WHERE created_at < DATEADD(day, -@archiveAfterDays, GETDATE())\n                  AND created_at >= DATEADD(day, -@retentionDays, GETDATE())\n            `;\n            \n            await execWriteCommand(deleteQuery, archiveParams);\n            \n            analyticsLogger.logOperation('ARCHIVE_OLD_RECORDS', {\n                table: tableName,\n                archiveTable: archiveTableName,\n                recordsArchived: archivedCount,\n                archiveAfterDays\n            });\n            \n            return { archived: archivedCount, size: archivedCount * 1024 }; // Estimated size\n            \n        } catch (error) {\n            if (error.message.includes('Invalid object name')) {\n                console.log(`Table ${tableName} does not exist, skipping archive`);\n                return { archived: 0, size: 0 };\n            }\n            throw error;\n        }\n    }\n    \n    /**\n     * Create archive table with same structure as main table\n     */\n    async createArchiveTable(sourceTable, archiveTable) {\n        try {\n            const createArchiveQuery = `\n                IF NOT EXISTS (SELECT * FROM sysobjects WHERE name='${archiveTable}' AND xtype='U')\n                BEGIN\n                    SELECT * INTO dbo.${archiveTable} FROM dbo.${sourceTable} WHERE 1=0\n                END\n            `;\n            \n            await execWriteCommand(createArchiveQuery);\n            \n        } catch (error) {\n            // Ignore errors if table already exists or source table doesn't exist\n            console.log(`Archive table creation for ${archiveTable}:`, error.message);\n        }\n    }\n    \n    /**\n     * Optimize database indexes\n     */\n    async optimizeIndexes() {\n        let indexesOptimized = 0;\n        \n        try {\n            const tables = ['TaskAnalytics', 'UserMetrics', 'UserExpertise'];\n            \n            for (const table of tables) {\n                // Rebuild indexes\n                const rebuildQuery = `\n                    IF EXISTS (SELECT * FROM sysobjects WHERE name='${table}' AND xtype='U')\n                    BEGIN\n                        ALTER INDEX ALL ON dbo.${table} REBUILD\n                    END\n                `;\n                \n                await execWriteCommand(rebuildQuery);\n                indexesOptimized++;\n            }\n            \n            analyticsLogger.logOperation('OPTIMIZE_INDEXES', {\n                tablesProcessed: tables.length,\n                indexesOptimized\n            });\n            \n        } catch (error) {\n            console.log('Index optimization error (expected if tables do not exist):', error.message);\n        }\n        \n        return indexesOptimized;\n    }\n    \n    /**\n     * Rebuild database statistics\n     */\n    async rebuildStatistics() {\n        try {\n            const tables = ['TaskAnalytics', 'UserMetrics', 'UserExpertise'];\n            \n            for (const table of tables) {\n                const updateStatsQuery = `\n                    IF EXISTS (SELECT * FROM sysobjects WHERE name='${table}' AND xtype='U')\n                    BEGIN\n                        UPDATE STATISTICS dbo.${table}\n                    END\n                `;\n                \n                await execWriteCommand(updateStatsQuery);\n            }\n            \n            analyticsLogger.logOperation('REBUILD_STATISTICS', {\n                tablesProcessed: tables.length\n            });\n            \n        } catch (error) {\n            console.log('Statistics rebuild error (expected if tables do not exist):', error.message);\n        }\n    }\n    \n    /**\n     * Get cleanup statistics\n     */\n    getCleanupStats() {\n        return {\n            ...this.cleanupStats,\n            retentionPolicies: this.retentionPolicies\n        };\n    }\n    \n    /**\n     * Update cleanup statistics\n     */\n    updateCleanupStats(processed, deleted, archived, errors) {\n        this.cleanupStats.lastRun = new Date().toISOString();\n        this.cleanupStats.totalRecordsProcessed += processed;\n        this.cleanupStats.totalRecordsDeleted += deleted;\n        this.cleanupStats.totalRecordsArchived += archived;\n        this.cleanupStats.errors = [...this.cleanupStats.errors, ...errors].slice(-100); // Keep last 100 errors\n    }\n    \n    /**\n     * Run manual cleanup\n     */\n    async runManualCleanup(type = 'daily') {\n        console.log(`Running manual ${type} cleanup...`);\n        \n        switch (type) {\n            case 'daily':\n                return await this.performDailyCleanup();\n            case 'deep':\n                return await this.performDeepCleanup();\n            case 'archive':\n                return await this.performMonthlyArchive();\n            default:\n                throw new Error(`Unknown cleanup type: ${type}`);\n        }\n    }\n    \n    /**\n     * Sleep utility for batch processing delays\n     */\n    sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n}\n\n// Create singleton instance\nconst analyticsCleanup = new AnalyticsCleanup();\n\nmodule.exports = {\n    AnalyticsCleanup,\n    analyticsCleanup\n};"